# 識別問題：演習課題

**注意：必要に応じて，再利用しやすいように課題ごとにコード名を変更して保存しておくようにすること．**

***
#### 課題 3.1
1. データ [`iris.csv`](./iris.csv) を確認する．また [データの設置されていたWebサイト（外部リンク）](https://archive.ics.uci.edu/ml/datasets/Iris) の説明を眺める．
1. コード [`svm_training.py`](./svm_training.py) と訓練データ [`iris_training.csv`](./iris_training.csv) を同じフォルダに設置する．そのフォルダに `linear_svm.pkl` というファイルが「存在しない」ことを確認しておく．そのあとコード [`svm_training.py`](./svm_training.py) を実行してみる．特に変化がないように見えるが，今度は `linear_svm.pkl` というファイルが作られていることを確認する．
1. コード [`svm_test.py`](./svm_test.py) ，テストデータ [`iris_test.csv`](./iris_test.csv)，そして学習したファイル（今回の場合は `linear_svm.pkl`）を同じフォルダに設置して，コード [`svm_test.py`](./svm_test.py) を実行する．結果の意味を考えてみる（どこかがおかしいのでは？）

    > 注意：環境によっては結果の出力が

    ```python
    [ 0.  0.  0. ...,  2.  2.  2.]
    [ 0.  1.  0. ...,  1.  1.  1.]
    ```

    のように省略される場合もある．
    これは長い配列を `print` で出力させようとしたときに，Pythonが勝手に省略して出力してしまっているからで，すべての要素を表示させるためにはたとえば出力の前に

    ```python
    np.set_printoptions(threshold=np.inf)
    ```

    と書く．`print` を使う前に「閾値(threshold)を無限にする，つまり，すべてを出力せよ」のように `print` オプションを設定しておくことにより，すべての要素が画面に表示されるようになる．

1. コード [`svm_training.py`](./svm_training.py) の意味を読み取る．
1. コード [`svm_test.py`](./svm_test.py) の意味を読み取る．
1. 実行結果でおかしな部分の原因を考える．コード [`svm_test.py`](./svm_test.py) を修正して，おかしな部分を取り除く．

    > ヒント：コード [`svm_training.py`](./svm_training.py) でのデータの準備方法とコード [`svm_test.py`](./svm_test.py) での準備方法に違いはないか？ データの全てを使っている？ それとも一部分だけ？ ここでは「2つの」クラスの識別を考えているので，テストについてもそのように変更したい）
    （さらにヒント：[`svm_test.py`](./svm_test.py) で全てのデータを読み込んだ後で，正解ラベルが 0 と 1 のもののみを使ってテストをするようにコードを修正する）

1. コード [`svm_plot.py`](./svm_plot.py) を実行する．またコードの意味を読み取ってみる．
1. コード [`svm_plot.py`](./svm_plot.py) を改造して（別のコードブロックを利用する,ファイル名を変更しておくなど，各自で工夫する），テストデータ [`iris_test.csv`](./iris_test.csv) に対するプロットを出力してみる．
1. 直線のSVMではなく，通常のSVMを使って学習する．訓練結果の出力の際，ファイル名を `svm.pkl` とする．
    > ヒント：ここで通常のSVMとは直線の代わりにRBFカーネルを用いたSVMのこと．
1. 通常のSVMを用いて学習した結果をテストデータに適用する．この際，課題3.1.6の修正も考慮する．
1. 通常のSVMを用いて訓練データ，テストデータに対するプロットをしてみる．
1. 学習の際に使う特徴を2種類から4種類に増やして訓練するコードを書く．その際，学習器の出力名を変えてみる．テストデータに適用して，結果を調べる（4次元なのでプロットは無理）．
1. プロットを png ファイル形式で保存する．
1. （発展）プロットする部分の意味を考えてみる．コードを変更しながら読み取った意味が正しいかどうかをチェックしてみる．たとえば一部分を拡大するなどした図を出力する．
1. （発展）サポートベクトルマシンについて調べる．特に「特徴空間」や「カーネル」というキーワードについて調べる．さらに，可能な人は数学的な記述に関しても調べてみる（これは難しい）．

***
#### 課題 3.2
1. 決定木，ランダムフォレストについてWebで調べ，理解を深めてみる．
1. ランダムフォレストについてwebで調べ，コード [`svm_training.py`](./svm_training.py) を書き換えて，ランダムフォレストで学習するコードを書く．type 2，つまりラベル2のデータを取り除いて学習する（以下，プロットについても同様）．なお，学習時の特徴量は4つとする．
1. 学習済みのランダムフォレストを使って，テストデータに対する分類結果を出力する．コード [`svm_test.py`](./svm_test.py) を参考にすること．
1. 学習済みのランダムフォレストを使って，訓練データと学習結果をプロットしてみる．コード [`svm_plot.py`](./svm_plot.py) を参考にすること．なお，プロットは最初の2つの特徴量のみで2次元とする（以下同様）．
1. 学習済みのランダムフォレストを使って，テストデータと学習結果をプロットしてみる．
1. プロット結果をSVMの結果と比較し，手法の違いを考慮しながら，なぜそのような違いが生じるのかについて考察する．
1. SVMを利用して，訓練データとして [`iris_validation_scale.csv`](./iris_validation_scale.csv) を用いて学習する．使用した訓練データと学習結果（直線・曲線）をプロットしてみる．
1. ランダムフォレストを利用して，訓練データとして [`iris_validation_scale.csv`](./iris_validation_scale.csv) を用いて学習する．使用した訓練データと学習結果をプロットしてみる．
1. データ [`iris_validation_scale.csv`](./iris_validation_scale.csv) に対するSVMとランダムフォレストの結果の違いについて考察する．
1. （発展）データの前処理として「標準化」をしてから学習し，結果をプロットしてみる．

    > ヒント：いろいろな方法があるが，例えば scikit-learn の `preprocessing`,`pipeline` といった機能を調べてみるといいかもしれない．

1. （発展）ランダムフォレストの数理的側面について調べる．

***
[>> 識別問題のトップページに戻る](./README.md)
***
<img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"> &nbsp; Jun Ohkubo
